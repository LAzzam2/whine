var http = require("http");
var querystring = require("querystring");

var PROBE_RE = /^[a-zA-Z0-9\/]+$/;

var probes = {};
var username, password;

/**
 * HTTP BasicAuth
 */
function authenticated(req, res) {
    var header = req.headers.authorization || '';
    var token = header.split(/\s+/).pop() || '';
    var auth = new Buffer(token, 'base64').toString();
    var parts = auth.split(/:/);
    
    if (username !== parts[0] && password !== parts[1]) {
        res.writeHead(401, {
            "Content-Type": "text/plain",
            "WWW-Authenticate": 'Basic realm="Monitoring"'
        });
        res.end("Please authenticate.");
        return false;
    }
    else
        return true;
}

function router(req, res) {
    if(!authenticated(req, res))
        return;
    var urlParts = req.url.substring(1).split('?');
    var probeName = urlParts[0];
    var queryArgs = {};
    if(urlParts[1]) {
        try {
            queryArgs = querystring.parse(urlParts[1]);
        } 
        catch(e) {
            console.log("Could parse arguments:", urlParts[1]);
        }
    }
    if(probeName === "") {
        res.writeHead(200, {"Content-Type": "text/plain"});
        res.end(JSON.stringify(Object.keys(probes)));
    } else if(!PROBE_RE.test(probeName)) {
        res.writeHead(404, {"Content-Type": "text/plain"});
        res.end("Not allowed");
    } else {
        var probe = probes[probeName];
        if(!probe) {
            res.writeHead(404, {"Content-Type": "text/plain"});
            res.end(JSON.stringify({status: "no-such-probe"}));
            return;
        }
        probe(queryArgs, function(err, result) {
            if(err) {
                res.writeHead(500, {"Content-Type": "text/plain"});
                res.end(JSON.stringify(err));
            }
            else {
                res.writeHead(200, {"Content-Type": "text/plain"});
                res.end(JSON.stringify(result));
            }
        });
    }
}

exports.define = function(name, fn) {
    probes[name] = fn;
};

exports.call = function(name, args, callback) {
    var probe = probes[name];
    if(!probe)
        return callback("not-found");
    probe(args, callback);
};

exports.start = function(port, user, passwd) {
    username = user;
    password = passwd;
    http.createServer(router).listen(port);
};

function Server(hostname, port, username, password) {
    this.hostname = hostname;
    this.port = port;
    this.username = username;
    this.password = password;
}

Server.prototype.probe = function(name, callback) {
    var req = http.request({
        host: this.hostname,
        port: this.port,
        path: "/" + name,
        headers: {
            Authorization: "Basic " + new Buffer(this.username + ":" + this.password).toString("base64")
        },
        method: 'GET'
    }, function(res) {
        if(res.statusCode !== 200)
            return callback(res);
        var bodyJson = '';
        res.setEncoding('utf8');
        res.on('data', function(chunk) {
            bodyJson += chunk;
        });
        res.on("end", function() {
            try {
                callback(null, JSON.parse(bodyJson));
            } catch(e) {
                callback("not-valid-json");
            }
        });
    });
    req.on('error', function(e) {
      callback(e.message);
    });
    req.end();
};

exports.Server = Server;

function parProbe(timeout, fns, callback) {
    var probesLeft = fns.length;
    var timedOut = false;
    var errors = [];

    var timeoutId = setTimeout(function() {
          timedOut = true;
          errors.push("Probe timed out");
          callback(errors);
    }, timeout);

    fns.forEach(function(fn) {
        fn(function(err) {
            if(timedOut)
                return;
            if(err)
                errors.push(err);
            probesLeft--;
            if(probesLeft === 0) {
                clearTimeout(timeoutId);
                callback(errors.length === 0 ? null : errors);
            }
        });
    });
}

exports.parProbe = parProbe;

exports.define("ping", function(args, callback) {
    callback(null, "ok");
});
